from typing import Any, List, Union


class Stack:
  def __init__(self) -> None:
    self.__stack = [] # Инициализируем пустой стек приватной переменной

  def push(self, value: Any) -> None:
    self.__stack.append(value) # Добавляем на верхушку стека значение

  def pop(self,) -> Any:
    if not self.isEmpty(): # Если стек не пуст
      return self.__stack.pop() # Удаляем элемент с верхушки стека и возвращаем его

    return None # В противном случае возвращаем None (Можно выбросить исключение)

  def top(self, ) -> Any: # Метод для возврата верхушки стека без его удаления
    return self.__stack[-1]

  def size(self, ) -> int: # Метод для возврата длины стека
    return len(self.__stack)

  def isEmpty(self, ) -> bool: # Метод для проверки пустоты стека
    return self.size() == 0

  def __str__(self, ) -> str: # for print
    return str(self.__stack)


def compute_postfix(expression: List[Union[int, str]]) -> int: # List = [1, 2, '+', 2, '-']; Подсчитывает выражение в постфиксной записи (ОПН)
  st = Stack() # На стеке будут лежать ТОЛЬКО числа для подсчета операций

  for elem in expression: # Мы бежим по каждому элементу во входном выражении (элемент может быть или числом, или операцией)
    if isinstance(elem, int): # isinstance(elem, int) - возвращает, является ли x переменной типа int
      st.push(elem) # Если получили число, закидываем его в стек

    else: # Иначе если мы получили операцию
      # 3 + 5: 3 сидит слева от операции, а 5 сидит справа
      second = st.pop() # На верхушке стека изначально мы положили последнее число (Last In First Out), т.е. которое справа от операции
      first = st.pop() # Чуть пониже стека лежит число слева от нужной операции

      if first != None and second != None: # Если со стека достали два числа без ошибок
        res = None # Переменная для подсчета результата

        # В зависимости от операции делаем нужное действие
        if elem == '+':
          res = first + second

        elif elem == '-':
          res = first - second

        elif elem == '*':
          res = first * second

        elif elem == '/':
          res = first / second

        elif elem == '//':
          res = first // second

        elif elem == '^':
          res = first ** second

        else: # Значит такой операции нет
          print('There is no such operation')
          return None

        st.push(res) # После подсчета операции нужно положить на верхушку стека результат выполнения (два предыдущих значения со стека мы уже удалили)

      else: # Если встретили None, значит неверное выражение (пример: compute_opn([5, '+', '*'])
        print('Wrong expression')
        return None

  # В конце на верхушке будет лежать результат выражения, мы его удаляем и сразу же возвращаем
  return st.pop()


def preparate_infix(data: str) -> List[Any]: # '(5 + 10)*2' -> ['(', 5, '+', 10, ')', '*', 2]
  data = data.replace(' ', '') # Лишние пробелы в выражении попросту не нужны

  expression = [] # Итоговое подготовленное выражение в инфиксной записи

  num = '' # Для подсчета числа (мы же получаем цифры в виде символов и нужно каждую последовательность цифр перевести в число и добавить в выражение)

  for symbol in data: # Пробегаем каждый символ в выражении без пробелов
    if symbol.isnumeric(): # Проверяет, является ли строка числом (в нашем случае цифрой)
      num += symbol

    elif num != '': # В этот elif мы зайдем, если очередной символ НЕ является цифрой (т.е. является операцией) И при этом у нас есть число (пример: '()^2', )^ выдаст пустую строку для числа
        expression.append(int(num)) # Добавляем в подготовленную инфиксную запись число
        num = ''  # Обнуляем буфер для числа
        expression.append(symbol) # В любом случае добавляем символ операции

    else:
      expression.append(symbol) # В любом случае добавляем символ операции

  if num != '': # Бывает такое, что в конце, например в выражении 5+6 в конце нет операции, не получится перейти в elif и else для числа 6, поэтому в конце его тоже нужно добавить к инфиксной записи
    expression.append(int(num))

  return expression


'''
Советую глянуть: http://trubetskoy1.narod.ru/ppn.html
'''
def infix_to_postfix(expression): # Тот самый перевод из инфиксной записи в постфиксную (ОПН)
  prior = {
      '(': 0, # Самый низкий приоритет у скобок
      '+': 1,
      '-': 1,
      '*': 2,
      '/': 2,
      '//': 2,
      '^': 3,
  } # Задаем приоритет операций

  st = Stack() # Стек исключительно для операций и скобок
  postfix = [] # Собственно сама постфиксная запись

  for elem in expression: # Бежим по каждому элементу (операция или число)
    if isinstance(elem, int): # Если число
      postfix.append(elem) # Просто кладем в постфиксную запись

    elif elem == '(': # Если скобка открывающая
      st.push(elem) # Кладем на верхушку стека саму скобку

    elif elem == ')': # Иначе если встретили закрывающую скоку
      while st.top() != '(': # Будем удалять со стека и добавлять в ОПН до тех пор, пока не встретим открывающую скобку
        postfix.append(st.pop())

      st.pop() # НО нужно еще же удалить саму '(' со стека


    else: # Вот тут мы встретили опреацию и в зависимости от приоритета будем добавлять другие операции со стека в ОПН
      while not st.isEmpty() and prior[elem] <= prior[st.top()]: # Пока стек не пуст (чтобы ошибок не было при удалении) и пока очередная операция из ВХОДНОГО выражения из по приоритету не превосходит верхушку стека
        postfix.append(st.pop()) # Просто добавляем эту верхушку стека

      st.push(elem) # В конце, тк мы обработали очередную операцию, ее надо положить на стек

    #print(postfix, st)

  while not st.isEmpty() and st.top() != '(': # В конце стек ведь не пуст, нужно удалить все операции в нем и добавить в постфиксную запись, здесь уже не важен приоритет
    postfix.append(st.pop())

  if not st.isEmpty(): # Если в конце остались какие-то необработанные операции, те кол-во открывающих или закрывающих скобок не совпадает, сори - у вас неверное выражение
    print('Wrong expression')
    return None

  return postfix

'''
data = input()
infix = preparate_infix(data) # Сначала предподготовка текста в список инфиксной записи
postfix = infix_to_postfix(infix) # Перевод из инфиксной записи в ОПН (постфиксная запись)
val = compute_postfix(postfix) # Подсчет ОПН (постфиксной записи)

print(val)
'''

def ret_val (data):
    infix = preparate_infix(data)  # Сначала предподготовка текста в список инфиксной записи
    postfix = infix_to_postfix(infix)  # Перевод из инфиксной записи в ОПН (постфиксная запись)
    val = compute_postfix(postfix)  # Подсчет ОПН (постфиксной записи)

    return val
